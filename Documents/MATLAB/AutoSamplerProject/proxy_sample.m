clear
clc

%-------------------Import audio------------------------------------------%
% filename = 'Beneath With Me (Full Unofficial Version) HD.mp3';
% [Y1,Fs]=audioread(filename);
% [Y2,Fs]=audioread(filename);
% 
% Original = Y1(20000:40000,1);                       % Extract short mono vector from "Y1" to use as refernece signal.
% Sample = Y2(20000:40000,1);                         % Extract short mono vector from "Y1" to use as sample signal.

Original = sin(linspace(0,2*pi,20));
Sample = zeros(size(Original));
Sample(round(size(Original,2)/3)) = 1;
plot(Sample)

%-------------------Slice-------------------------------------------------%
Nslice = 1;                                                % Number of samples to extract from "Sample". (A Sample in music production, is understood as being a snippet of sound).
S = Slicer(Sample,Nslice);                                  % Create instance of "Slicer" class using "Sample" as audio and "Nslice" as the number of slices to create.
G = gradDescent;                                            % Create instance of "gradDescent" class.
getError = @(A) L2_vecNorm(S.mkRender(A)-toCol(Original));  % Function to be minimised. "getError" creates the render of the Slicer object using the current shift an coefficient values (passed to the function as "A") stored in the Slicer object "S", then uses the L2 vector norm on the element-wise difference between the "S.OutRender" and the "Original" vectors.

%-------------------Aproximate using slices-------------------------------%
figure
plot(Original)
title('Original Audio')
step = 1;                                                  % Stepsize to be used in dirfference quotient for gradient descent. "step" must be whole number.
NumIterations = 100;
errorVec = zeros(1,NumIterations);
figure

for number = 1:NumIterations
    S.mkRender([round(S.getsliceShift);S.getsliceCoeff]);
    plot(S.getOutRender)                                                                                    % Plot the vector generated by "S.mkRender" once it was called by "getError".
    title('Synthesized Audio')
    pause(0.1)
    gradient = (abs(G.grad(getError,ceil(abs(step)),[round(S.getsliceShift);S.getsliceCoeff])));        % Calculate the gradient of the "getError" function at the point X0 = [abs(S.getsliceShift),S.getsliceCoeff]. ciel(abs(step)) ensures that the "step" value passed to G.grad is positive and a whole number.
    errorVec(number) = getError([abs(round(S.getsliceShift));S.getsliceCoeff]);
    S.setsliceShift(S.getsliceShift-step*gradient(1:Nslice));                                           % Descend gradient for "Shift" values.
    S.setsliceCoeff(S.getsliceCoeff-step*gradient((Nslice+1):(2*Nslice)));                              % Descend gradient for "Coeff" values.
end
figure
plot(errorVec)
title('Error vs. Iterations')
%-------------------export audio------------------------------------------%

%Outfile = 'mangledFile';
%audiowrite(Outfile,S.getOutRender,Fs)




